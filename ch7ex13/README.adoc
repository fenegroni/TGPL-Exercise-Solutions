= Exercise 7.13
// Refs:
:url-base: https://github.com/fenegroni/TGPL-exercise-solutions
:url-workflows: {url-base}/workflows
:url-actions: {url-base}/actions
:badge-exercise: image:{url-workflows}/Exercise 7.13/badge.svg?branch=main[link={url-actions}]

{badge-exercise}

Add a `String` method to `Expr` to pretty-print the syntax tree.
Check that the results, when parsed again, yield an equivalent tree.

== Test

We have three options to test this.

The first two options take less time to implement,
because they don't compare the resulting expression tree directly.

1. Given a known expression with a known result,
calling `Eval` on the string representation
yields the same result.

2. Given any expression,
if we first call `Parse` on it,
then we call `String` on the resulting `Expr`,
if we call `Parse` on that resulting string
and then call `String` on the `Expr`
the first `String` result should match the second `String` result.

3. Given any expression,
if we first call `Parse` on it,
then we call `String` on the resulting `Expr`,
if we call `Parse` on that resulting string

The third option we have is similar to the second one,
except instead of comparing the string result,
we deep compare the tree of `Expr`.

The reason I don't particularly like the third option at this stage
is because it's asking us to either expose how `Expr` is implemented
to the test, or implement an `Expr`-tree comparison function.

This would require more code that is superflous at this stage,
but for the sake of the exercise, which is to learn Go,
I will implement that function.

=== Option 1: Using `Eval`

The first test, `TestStringEval`, uses the first strategy.

We apply `Eval` to an expression that we know are parsed and evaluated correctly
(see `TestEval` in `expr_test.go`).

Then we take the string repsentation of the parsed expression
and apply `Eval` to it.

If we get the same result from both evaluations,
we _know_ the string representation is compatible.

Obviously we could think of cases where
two expressions which are different give the same results:
that's why this strategy is a little flaky.

=== New type args

While implementing `String` for `call`,
I realised that since the arguments are stored in a `[]Expr`,
a bit of logic is needed to represent them properly in string format.

So I decided to create the new type `args`
to implement the `fmt.Stringer` interface.
